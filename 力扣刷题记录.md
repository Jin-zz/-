---
typora-root-url: resources
---

力扣刷题记录

Wrote by  @Greennbananaaa

[TOC]

## [面试题03. 数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

找出数组中重复的数字。


在一个长度为 n 的数组 nums 里的**所有数字都在 0～n-1 的范围内**。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

示例 1：

输入：
`[2, 3, 1, 0, 2, 5, 3]`
输出：`2 或 3` 

限制：

`2 <= n <= 100000`



**解答：**

注意 数组中的值均小于 n-1

1. 空间复杂度n,时间复杂度n

   - 利用 HashSet 的哈希冲突，set.add(nums[i])，添加已经存在的值返回 **false**

     ```java
     class Solution {
         public int findRepeatNumber(int[] nums) {
             Set<Integer> set = new HashSet<Integer>();
             for (int num : nums) {
                 if (!set.add(num)) {
                     return num;
                 }
             }
             return -1;
         }
     }
     
     ```

     

   - 新建数组rec存储，长度n-1，令 `rec[nums[i]] = 1` 

     ```java
     class Solution {
         public int findRepeatNumber(int[] nums) {
             int[] rec = new int[nums.length];
             for(int i = 0;i<nums.length;i++){
                 if(rec[nums[i]]==1) return nums[i];
                 else rec[nums[i]] = 1; 
             }
             return 0;
         }
     }
     ```

     

   

2. 空间复杂度 1，时间复杂度n，将原数组作为容器，判断是否存在

   输入：
   nums =  `[2, 3, 1, 0, 2, 5, 3]`

   注意判断条件 `nums[i] !=i`

   **i = 0**

   i=0 change(0,nums)  **0 与 nums[0]=2 交换** nums = `[1,3,2,0,2,5,3]` 

   i=0 change(0,nums)  **0 与 nums[0]=1 交换**nums= `[3,1,2,0,2,5,3]`

   i=0 change(0,nums)  **0 与 nums[0]=3交换**nums= `[0,1,2,3,2,5,3]`

   **nums[0] == 0	 i++**

   **i=1 nums[1] == 1 	i++**

   **i=2 nums[2]==2 	i++**

   **i=3 nums[3]==3	 i++**

   **i=4 nums[4]!=4  but nums[4] == nums[nums[4]]=nums[2]  返回 nums[4]=2**

   

   ```java
   class Solution {
       public int findRepeatNumber(int[] nums) {
           for(int i=0;i<nums.length;i++){
               while(nums[i]!=i){
                   if(nums[i] == nums[nums[i]]){
                       return nums[i];
                   }
                   nums = change(i,nums);
               }         
           }
           return -1;
       }
   
       int[] change(int i,int[] nums){
           int temp = nums[i];
           nums[i] = nums[temp];
           nums[temp] = temp;
           return nums;
       }
   }
   ```




## [面试题04. 二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 

示例:现有矩阵 matrix 如下：

`[`
  `[1,   4,  7, 11, 15],`
  `[2,   5,  8, 12, 19],`
  `[3,   6,  9, 16, 22],`
  `[10, 13, 14, 17, 24],`
  `[18, 21, 23, 26, 30]`
`]`

给定 `target = 5`，返回 `true`。

给定 `target = 20`，返回 `false`。

限制：

`0 <= n <= 1000`

`0 <= m <= 1000`



**解答：**

1. 暴力法：遍历二维数组，由于此二维数组是矩形，行数和列数都是可以确定的

   二维数组的行数：arr.length 

   二维数组的列数：arr[0].length

   ```java
            for(int i=0;i<matrix.length;i++){
              //不固定列数： for(int j=0;j<matrix[i].length;j++)
                for(int j=0;j<matrix[0].length;j++){
                    if(matrix[i][j]==target) return true;
                }
            }
            return false;
   ```

   

2. 从第一行中值开始搜索：即从 matrix[0].length/2 的地方开始搜索。

   若target<中值（索引temp对应的值），索引temp--，直到遇到该行小于tar的最大值，判断该边缘值是否等于tar，不等于则继续搜索下一行，从下一行的索引temp处开始搜索；

   若tar>中值（索引temp对应的值），索引temp--，直到遇到该行大于tar的最小值，判断该边缘值是否等于tar，不等于则继续搜索下一行，从下一行的索引temp处开始搜索；

   **⚠️该法会回头，例如查询20是否存在，不回头的搜索是从左下或者右上开始**

   ```java
   //二分开始查找
           int temp = matrix[0].length/2;
           int i = 0;
           while(i<matrix.length){      
                while(target<matrix[i][temp]){
                    if(temp==0) break;
                    temp--; 
                }
                while(target>matrix[i][temp]){
                    if(temp==matrix[0].length-1) break;
                    temp++;
                }
                
                if(target==matrix[i][temp]) return true;
                i++;
           }
   				return false;
   ```

   

## [面试题05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

请实现一个函数，把字符串 s 中的每个空格替换成"%20"。

示例 1：

输入：`s = "We are happy."`
输出：`"We%20are%20happy."`

限制：

`0 <= s 的长度 <= 10000`

来源：力扣（LeetCode）

**解答：**

直接循环查找替换，但注意string是常量，对其进行连接等操作代价比较高，相当于生成新常量存进去。

基于执行速度 建议使用StringBuilder，[StringBuilder > StringBuffer >  String]

原因：String是字符串常量，StringBuider以及StringBuffer是字符串变量，所以在进行字符串拼接的时候，String相比较这两个，多了一个对象的创建跟回收，所以String效率最慢。

```java
       //直接使用string进行连接操作
				String str = "%20";
        String res = new String();
        int start = 0;
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)==' '){
                res = res + s.substring(start,i);
                res = res + str;
                start = i+1;
            }
        }
        res = res + s.substring(start,s.length());
        return res;
```

```java
        //使用 StringBuilder 进行拼接字符串，再转成 String
				StringBuilder res = new StringBuilder();
        char[] ss = s.toCharArray();
        for(int i=0;i<ss.length;i++){
            if(ss[i]==' '){
                res.append("%20");
            }
            else res.append(ss[i]);
        }
        return res.toString();
```



## [面试题06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

示例 1：

输入：`head = [1,3,2]`
输出：`[2,3,1]`

限制：

`0 <= 链表长度 <= 10000`

**解答：**

```java
// ListNode 的定义
public class ListNode {
  int val;
	ListNode next;
	ListNode(int x) { val = x; }
}
```

利用中间容器倒序存储

1.利用stack先进后出，即倒序输出，先将ListNode遍历转为stack，再依次push到数组中，数组长度等于stack.size().

```java
class Solution {
    public int[] reversePrint(ListNode head) {
        LinkedList<Integer> stack = new LinkedList<Integer>();
        while(head != null) {
            stack.addLast(head.val);
            head = head.next;
        }
        int[] res = new int[stack.size()];
        for(int i = 0; i < res.length; i++)
            res[i] = stack.removeLast();
    return res;
    }
}

```

2.如果已知链表长度，则顺序遍历链表，倒序存进数组即可。

```java
lass Solution {
    public int[] reversePrint(ListNode head) {
        int i=0;
        ListNode gg = head; //另存头节点 
        if(head==null) return new int[0];
				//获取链表长度 i
        while(head.next!=null){
            if(head.next!=null) head = head.next;
            i++;
        }
    
        int[] res = new int[i+1];
      //顺序遍历链表，倒序存储数组
        while(i>0){
            res[i] = gg.val;
            if(gg.next!=null) gg = gg.next;
            i--;
        }
        res[i] = gg.val;
        return res;

    }
```

两种方法时间复杂度相同，基本都是2n = o(n)，第二种方法不另外花费存储空间。



## [面试题07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

例如，给出

`前序遍历 preorder = [3,9,20,15,7]`
`中序遍历 inorder = [9,3,15,20,7]`

返回如下的二叉树：

       3
      / \
     9  20
       /  \
      15   7

限制：

`0 <= 节点个数 <= 5000`

**解答**：注意此题没有重复元素

1. **递归**，先找到头节点，分别返回左子树段，右子树段；再从左子树/右子树中找到头节点，再返回其左子树/右子树……直到长度为0或超出范围

   根节点 i：前序段中的第一个值 即preorder的头

   左子树段长度 len：在中序中找到该值，返回[索引-该段inorder的头]

   左子树表示：preorder=[preorder的头+1,preorder的头+len] ;  inorder=[inorder的头，inorder的头+len-1]

   右子树表示：preorder=[preorder的头+len+1,preorder的尾] ； inorder=[inorder的头+len+1, inorder的尾]

   每次新返回的节点为该段的根节点，即前序的头节点preorder[prestart]

   ```java
   /**
    * Definition for a binary tree node.
    * public class TreeNode {
    *     int val;
    *     TreeNode left;
    *     TreeNode right;
    *     TreeNode(int x) { val = x; }
    * }
    */
   class Solution {
       public TreeNode buildTree(int[] preorder, int[] inorder) {
         //设置一个哈希表查找中序中与头节点相同的值，并获得索引，从而得到子树的len
         //哈希表比while要快，作用上是等价的
           HashMap<Integer,Integer> map = new HashMap<>();
           for(int i =0;i<inorder.length;i++){
               map.put(inorder[i],i); // (值，索引）
           }
         //开始递归
           TreeNode tree = findTree(map,preorder,inorder,0,preorder.length-1,0,inorder.length-1);
   
           return tree;
       }
   
       TreeNode findTree(HashMap map,int[] preorder, int[] inorder,int prestart,int preend,int instart,int inend){
           if(preorder.length==0) return null;
           if(prestart>preend||instart>inend) return null;
           int len = Integer.parseInt(map.get(preorder[prestart]).toString()) - instart;     
           // while(preorder[prestart]!=inorder[len+instart]){
           //     len++;           
           // }
           TreeNode tree = new TreeNode(preorder[prestart]);
           tree.left = findTree(map,preorder,inorder,prestart+1,prestart+len,instart,instart+len-1);
           tree.right = findTree(map,preorder,inorder,prestart+len+1,preend,instart+len+1,inend);
   
           return tree;
       }
   }
   ```

   

2. **迭代**，按照前序遍历的顺序，依次插入树中，用栈存储已经遍历过的根节点。【较快】

   先插入根节点3，并进栈[3]；

   判断栈顶3是否等于inorder[index=0]，不等则9是左子树，9进栈[3,9]；

   判断栈顶9是否等于inorder[index=0]，此时相等，相等的话则开始右子树遍历：先将栈中属于左子树和根节点的部分退栈，并index++，直到**栈空**或**退出的栈顶和inorder[index]不等**，此时栈空，index=2，此次循环中的20即是最后退栈的元素3的右子树，并进栈[20]；

   判断栈顶20是否等于inorder[index=2]，不等则15是左子树，15进栈[20,15]；

   判断栈顶15是否等于inorder[index=2]，此时相等，相等的话则开始右子树遍历：先将栈中属于左子树和根节点的部分退栈，并index++，直到**栈空**或者**退出的栈顶和inorder[index]不等**，此时栈空，index=4，此次循环中的7即使最后退栈的元素20的右子树，进栈[7];

   返回根节点；

   `前序遍历 preorder = [3,9,20,15,7]`
   `中序遍历 inorder = [9,3,15,20,7]`

   ```java
   class Solution {
       public TreeNode buildTree(int[] preorder, int[] inorder) {
           if (preorder == null || preorder.length == 0) {
               return null;
           }
           TreeNode root = new TreeNode(preorder[0]);
           int length = preorder.length;
           Stack<TreeNode> stack = new Stack<TreeNode>();
           stack.push(root);
           int inorderIndex = 0;
           for (int i = 1; i < length; i++) {
               int preorderVal = preorder[i];
               TreeNode node = stack.peek();
               if (node.val != inorder[inorderIndex]) {
                   node.left = new TreeNode(preorderVal);
                   stack.push(node.left);
               } else {
                   while (!stack.isEmpty() && stack.peek().val == inorder[inorderIndex]) {
                       node = stack.pop();
                       inorderIndex++;
                   }
                   node.right = new TreeNode(preorderVal);
                   stack.push(node.right);
               }
           }
           return root;
       }
   }
   
   ```



## [面试题09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 `appendTail` 和 `deleteHead` ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，`deleteHead` 操作返回 -1 )

示例 1：

```
输入：
["CQueue","appendTail","deleteHead","deleteHead"]
[[],[3],[],[]]
输出：[null,null,3,-1]
```

示例 2：

```
输入：
["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]
```

提示：

`1 <= values <= 10000`
最多会对 `appendTail、deleteHead` 进行 10000 次调用

**解答**：

该题中，`Stack，ArrayDeque，LinkedList`都可以作为栈使用，频繁的插入、删除操作建议使用 `LinkedList`。

1. Stack:注意对栈进行pop/push操作，传递的是逻辑地址，因此原栈会被改变，即使是作为参数传入子函数

   ```java
   class CQueue {
       private Stack<Integer> stack1;
       private Stack<Integer> stack2;
       public CQueue() {
           stack1 = new Stack<Integer>();
           stack2 = new Stack<Integer>();
       }
       
       public void appendTail(int value) {
           reversestack(stack2,stack1);//将stack2的内容倒序插入stack1，stack2空
           stack1.push(value);
       }
       
       public int deleteHead() {
           reversestack(stack1,stack2); //将stack1的内容倒序插入stack2，stack1空
           if(stack2.empty()) return -1;
           return stack2.pop();
       }
       
     //翻转栈，将栈a中所有内容倒序插入b,b原有内容不变,最终a为空
       private void reversestack(Stack a,Stack b){
           while(!a.empty()){
               b.push(a.pop());
           }
       }
   }
   
   /**
    * Your CQueue object will be instantiated and called as such:
    * CQueue obj = new CQueue();
    * obj.appendTail(value);
    * int param_2 = obj.deleteHead();
    */
   ```

   

2. LinkedList: 含有首尾指针，甚至不需要翻转栈

   ```java
   class CQueue {
       private LinkedList<Integer> link1;    
       public CQueue() {
           link1 = new LinkedList<Integer>();
       }
       
       public void appendTail(int value) {
           link1.addFirst(value);        
       }
       
       public int deleteHead() {
           if(link1.isEmpty()) return -1;
           return link1.removeLast();
       }
   
   }
   ```

   

## [面试题10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：

F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.

斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

示例 1：

`输入：n = 2`
`输出：1`

示例 2：

`输入：n = 5`
`输出：5`

提示：

    0 <= n <= 100



**解答：**

int和long只能写10个数字，short只能写5个数字，多了就会报错。

float只能写小数点后6位，double的小数点后16位。

```java
class Solution {
    public int fib(int n) {
        int i = 1;
        int[] a = {0,1};
        if(n<1) return a[0];
        int res = a[1];
        while(i<n){
            res = (a[1] + a[0])%(1000000007);  //计算结果超出int的长度，需要取模
            a[0] = a[1];
            a[1] = res;
            i++;
        }
        return res;
    }
}
```



## [面试题10- II. 青蛙跳台阶问题](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

示例 1：

`输入：n = 2`
`输出：2`

示例 2：

`输入：n = 7`
`输出：21`

提示：

    0 <= n <= 100

**解答：**

> f(0) = 1
>
> f(1) = 1 =  $C^0_1$
>
> f(2) = 2 = $C^0_2 + C^1_1$
>
> f(3) = 3 = $C^0_3 + C^1_2$
>
> f(4) = 5 = $C^0_4 + C^1_3 + C^2_2$
>
> f(5) = 8 = $C^0_5 + C^1_4 + C^2_3$
>
> ……
>
> 其实有递推公式：f(n) = f(n-1)+f(n-2)	n>=2
>
> 该题排列组合的方法在原理上也可以，但计算中容易超出int长度导致计算结果不正确
>
> **建议还是使用递推公式计算，与斐波那契数列相似**

```java
class Solution {
    public int numWays(int n) {
        // int start = 0; //start++
        // int last = n;  //last--
        if(n<2) return 1;
        int sum=0;
        int a = 1;
        int b = 1;
        int i = 2;
        while(i<=n){
            sum = (a+b)%(1000000007);
            a = b;
            b = sum;
            i++;
        }
        return sum;
    }
    
    //计算排列组合 方法没错 但数字太大会超出长度 不好处理
    double sortzuhe(int n, int m){
        if(m<=n/2) m = n-m;
        double up = 1;
        double down = 1;
        for(int i=m+1;i<=n;i++){
            up = up * i ;
        }
       // System.out.println(up);
        for(int j = 1;j<=(n-m);j++){
            down = down * j ;
        }
        //System.out.println(down);
        return (up/down);
    }
}
```



## [面试题11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  

示例 1：

`输入：[3,4,5,1,2]`
`输出：1`

示例 2：

`输入：[2,2,2,0,1]`
`输出：0`

**解答：**

> 有序数组问题 考虑二分法 
>
> 虽然该题直接倒序遍历也可，但在数组长度很大的情况下，二分法无疑更优

二分中值m>右端值，最小值一定在右边，取[m+1,右端];

二分中值m<右端值，最小值一定在左边，取[左端,m];

二分中值m=右端值，有多种情况，但可以知道的是最小值一定不是右端值，则 `j--`;

```java
class Solution {
    public int minArray(int[] numbers) {
        //倒序遍历
        //if(numbers.length==1) return numbers[0];
        // int i = numbers.length - 2;  
        // int res = numbers[numbers.length-1];
        // while(i>=0){         
        //     if(res>=numbers[i]){
        //         res = numbers[i];
        //     }
        //     else return res;
        //     i--;
        // }
        // return res;
      
				//二分法
        int i = 0;
        int j = numbers.length-1;
        while(i<j){
            int m = (i+j)/2;
            if(numbers[m]>numbers[j]) i = m+1;
            else if(numbers[m]<numbers[j]) j = m;
            else j--;
        }
        return numbers[j];
    }
}
```



## [面试题12. 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。

`[["a","b","c","e"],`
`["s","f","c","s"],`
`["a","d","e","e"]]`

但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。

示例 1：

`输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"`
`输出：true`

示例 2：

`输入：board = [["a","b"],["c","d"]], word = "abcd"`
`输出：false`

提示：

    1 <= board.length <= 200
    1 <= board[i].length <= 200

**解答：**

> **深度优先搜索（DFS）**
>
> DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。
>
> 方向：下上右左
>
> 返回 `false` 的情况：超出数组范围/不等于对应的字符/该字符已被访问
>
> 最终只有一条线返回 `true` ：即字符遍历完成 `i = word.length-1`
>
> 注意：每次遍历后 如果返回`false`往回传的过程中，要**还原 访问矩阵**

```java
class Solution {
    public boolean exist(char[][] board, String word) {

        char[] words = word.toCharArray();   //转string到chars数组 访问会更快  
        int[][] record = new int[board.length][board[0].length];  //记录访问与否的空矩阵
      //该记录矩阵可用board代替 即在每次循环中将board的值设为'/'[永远不等] 并存储该位置的原数据
      //还原时还原 原数据
        
        for(int i=0;i<board.length;i++){
            for(int j=0;j<board[0].length;j++){
                if(findnext(board,record,words,i,j,0)) return true;
            }
        }
        return false;
    }

    boolean findnext(char[][] board,int[][] record,char[] words,int start_i,int start_j,int i){
        if(i==words.length) return true;  // 唯一true返回路径
        if(start_i<0||start_j<0||start_i==board.length||start_j==board[0].length||board[start_i][start_j]!=words[i]||record[start_i][start_j]==1) return false;
      //返回 false 的条件：超出范围/与对应char不相等/该值已被访问
        
        record[start_i][start_j] = 1; //被访问的数字设为 1 
      //该记录矩阵可用board代替 即在每次循环中将board的值设为'/'[永远不等] 并存储该位置的原数据
      //还原时还原 原数据
        
        boolean tmp = findnext(board,record,words,start_i+1,start_j,i+1)||findnext(board,record,words,start_i-1,start_j,i+1)||findnext(board,record,words,start_i,start_j+1,i+1)||findnext(board,record,words,start_i,start_j-1,i+1);
        record[start_i][start_j] = 0;  // 该次循环失败或已经成功 还原访问矩阵
        return tmp;
    }

}
```



## [面试题13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

地上有一个m行n列的方格，从坐标 `[0,0]` 到坐标 `[m-1,n-1]` 。一个机器人从坐标 `[0, 0] `的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

**示例 1：**

```
输入：m = 2, n = 3, k = 1
输出：3
```

**示例 1：**

```
输入：m = 3, n = 1, k = 0
输出：1
```

**提示：**

- `1 <= n,m <= 100`
- `0 <= k <= 20`

**解答：**

> 考察 **深度优先搜索（DFS）**
>
> DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。
>
> 方向：下上右左
>
> 返回 0 的条件：超出范围/该坐标下标和大于k/该值已被遍历
>
> 若该点满足条件，该点count=1，继续遍历该点的四个方向，最终返回1+四个方向的值
>
> 注意遍历的过程中，**record(标记矩阵)会不断向前传递**，该题与上一题不同的地方在于**标记矩阵不需要还原**

```java
class Solution {
    public int movingCount(int m, int n, int k) {
        int count = 0;
        boolean[][] record = new boolean[m][n]; //标记矩阵

        //count = dfscount(m,n,0,0,k,count,record);
        
        return dfscount(m,n,0,0,k,count,record);
    }

    int dfscount(int m, int n,int i,int j,int k,int count,boolean[][] record){
        if(i<0||j<0||i==m||j==n||!isbelong(i,j,k)||record[i][j]) return 0; //不满足条件

        record[i][j] = true; //更新标记矩阵
				
      	//dfs 遍历
        count = 1 + 
        dfscount(m,n,i+1,j,k,count,record) + 
        dfscount(m,n,i-1,j,k,count,record) +
        dfscount(m,n,i,j-1,k,count,record) +
        dfscount(m,n,i,j+1,k,count,record);


        return count;
    }

  	//矩阵m,n的值均小于100,不用考虑三位数的情况
    boolean isbelong(int i,int j,int k){
        if((i/10+i%10+j/10+j%10)>k) return false;  //大于k 返回false
        else return true;
    }
}
```



## [面试题14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)

给你一根长度为 `n` 的绳子，请把绳子剪成整数长度的 `m` 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 `k[0],k[1]...k[m]` 。请问 `k[0]*k[1]*...*k[m]` 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

**示例 1：**

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
```

**示例 2:**

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
```

**提示：**

- `2 <= n <= 58`

**解答：**

| n    | 最大划分 | Result        |
| :--- | :------- | :------------ |
| 2    | [1,1]    | 1             |
| 3    | [2,1]    | 2             |
| 4    | [2,2]    | 2*2=4         |
| 5    | [2,3]    | 2*3=5         |
| 6    | [3,3]    | 3^2^=9        |
| 7    | [3,2,2]  | 3 *2 * 2 = 12 |
| 8    | [3,3,2]  | 3 * 2 * 3 =18 |
| 9    | [3,3,3]  | 3^3^ = 27     |

n>3时，所有的数都可以拆成 **若干个 3 和 2 的集合**，此时乘积最大

`n/3=a`   

`n%3=1`  拆成 [a-1个3，2，2] = 3^a-1^ * 2 *2;

`n%3=2`  拆成 [a个3，2] = 3^a^ * 2;

`n%3=3`  拆成 [a个3] = 3^a^;

```java
class Solution {
    public int cuttingRope(int n) {
        if(n<=3) return n-1;
        int a = n/3;
        int b = n%3;
        if(b==0) return (int)Math.pow(3,a);
        else if(b==1) return (int)Math.pow(3,a-1)*4;
        else return (int)Math.pow(3,a)*2;
    }
}
```



## [面试题14- II. 剪绳子 II](https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/)

给你一根长度为 `n` 的绳子，请把绳子剪成整数长度的 `m` 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 `k[0],k[1]...k[m]` 。请问 `k[0]*k[1]*...*k[m]` 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

**示例 1：**

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
```

**示例 2:**

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 
```

**提示：**

- `2 <= n <= 1000`

**解答：**

<img src="/Users/jinzhuoqun/Documents/StudyNotes/力扣刷题记录/resources/面试题14- II.jpg" alt="面试题14- II" style="zoom:50%;" />

> n = n -3;
>
> res= res*3;
>
> 当n=<4时，剩4/3/2，即res = res*4/3/2 即为最终答案
>
> 与上题相似，可以将最后三种情况合并做，让n从大到小迭代。
>
> 注意这题会超出int长度，因此设置res的类型为long，再取余。
>
> **取余的乘积公式：**
>
> `(xy)%p=[(x%p)(y%p)]%p`
>
> (x*3)%(1000000007) = [(x%1000000007) * 3]%1000000007

```java
class Solution {
    public int cuttingRope(int n) {
        // if(n<4) return n-1;
        // long res = 1;
        // while(n>4){
        //     res = (res*3)%1000000007;
        //     n-=3;
        // }
        // return (int)(res*n%1000000007);
        return n<4? n-1:(int)getres(n);

    }
    long getres(long n){
        return n>4? 3*getres(n-3)%1000000007:n;
    }

}
```





## [面试题15. 二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。

示例 1：

```
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```

示例 2：

```
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
```

示例 3：

```
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```

注意：输入的n为无符号数字

**解答：**

1. 位右移，左侧补0，无符号右移是<<<，有符号右移是<<（负数左侧补1），判断其与1的与运算

   ```java
   public class Solution {
       // you need to treat n as an unsigned value
       public int hammingWeight(int n) {
           int res = 0;
           while(n!=0){
               //法一 位右移
               res+=n&1;
               n>>>=1;
               //int tmp = n&1;
               //if(tmp==1) res++; //这里直接写if(n&1==1)会报错!
               //n>>>=1;          
            }
           return res;
       }
   }
   ```

   

2. n&(n-1) 可以消掉最右的1，直到该数为0

   ```java
   public class Solution {
       // you need to treat n as an unsigned value
       public int hammingWeight(int n) {
           int res = 0;
           while(n!=0){
               //法二 n&(n-1) 可以消掉最右的1
                res++;
                n&=n-1;          
            }
           return res;
       }
   }
   ```

   

## [面试题16. 数值的整数次方](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)

实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。

示例 1:

```
输入: 2.00000, 10
输出: 1024.00000
```

示例 2:

```
输入: 2.10000, 3
输出: 9.26100
```

示例 3:

```
输入: 2.00000, -2
输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25
```

**说明:**

- -100.0 < *x* < 100.0
- *n* 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。

**解答：**

3^10^=3^1010^=3^( 2^3^*1+2^2^*0+2^1^*1+2^0^*0)=  3^8*1^ * 3^4*0^ * 3^2*1^ * 3^1*0^ =  3^8*1^ * 1 * 3^2*1^ * 1 

`(b&1)==1` 判断二进制最后一位是不是1，等价于 `b%2==1`；

`b>>=1` 右移一位 相当于该数减半，等价于 `b=b/2`;

```java
class Solution {
    public double myPow(double x, int n) {
        double res = 1;
        long b = n;
        
        if(n<0){
            x=1/x;
            b=-b;
        }
        while(b>0){
            if((b&1)==1) res = res*x;
            x*=x;
            b>>=1;
        } 
        return res;
    }
}
```

递归算法：减半的平方并乘以系数（1或者x）

3^10^ = 1*(==3^5^==)^2^ = 1 * (==3 * (3^2^)^2^==)^2^ =  1 * (3 * (1 * (==1 * 3 * 3== )^2^)^2^)^2^ 

```java
class Solution {
    public double myPow(double x, int n) {
        if(n==1) return x;
        if(n==0) return 1;
        if(n==-1) return 1/x;
        double half = myPow(x, n / 2); //减半
        double mod = myPow(x, n % 2);  //判断是0还是1 偶数还是奇数 奇数要乘以x
        return half * half * mod;  
    }
}
```

## [面试题 16.11. 跳水板](https://leetcode-cn.com/problems/diving-board-lcci/)

你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。

返回的长度需要从小到大排列。

示例：

```
输入：
shorter = 1
longer = 2
k = 3
输出： {3,4,5,6}
```

提示：

`0 < shorter <= longer`
`0 <= k <= 100000`

**解答：** 返回数组长度=k+1，特殊情况：k=0；shorter==longer

```java
class Solution {
    public int[] divingBoard(int shorter, int longer, int k) {
        if(k==0) return new int[0];
        if(shorter==longer) return new int[]{shorter * k}; //1 1 100 返回[100]

        int[] res = new int[k+1];
        for(int i=0;i<=k;i++){
            // L S k=3 返回[0*L+3*S,1*L+2*S,…] 长度k+1
            res[i] = i*longer + (k-i)*shorter;
        }
        return res;
    }
}
```



## [面试题17. 打印从1到最大的n位数](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)

输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。

示例 1:

```
输入: n = 1
输出: [1,2,3,4,5,6,7,8,9]
```

说明：

    用返回一个整数列表来代替打印
    n 为正整数

**解答：**

```java
class Solution {
    public int[] printNumbers(int n) {
         int len = (int)Math.pow(10,n)-1;
         int[] res = new int[len];
         for(int i=0;i<len;i++){
             res[i]=i+1;
         }
         
        return res;
    }
}
```

实际上是考察**大数定理**。

本题原意考察在n为超大值的情况下，int类型不能满足输出，需要采用字符串的方式。

大数打印：可以设定一个阈值，例如long的最大值，当超过了这个最大值，将阈值转为字符数组toCharArray()，然后继续+1打印，这样可以提高时间效率，因为一部分的数仍是O(1)打印





## [面试题18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

注意：此题对比原题有改动

示例 1:

```
输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
```

示例 2:

```
输入: head = [4,5,1,9], val = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.
```

说明：

    题目保证链表中节点的值互不相同
    若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点



**解答：**

判断head.next.val是不是我们需要的值，是的话就跳过该节点

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        ListNode start = head;
        if(head.val==val) return head.next;
       //本质是判断head.next.val是不是我们需要的值，是的话就跳过该节点
        while(head.next!=null){
            if(head.next.val!=val) head = head.next;
            else head.next = head.next.next;
        }
        return start;

    }
}
```

原书中给出的删除函数是：deleteNode(ListNode head,ListNode tobedelete)，即给出了要删除的节点指针，那么我们只需要将 ListNode tobedelete 的下一个节点复制到当前delete的节点，再将当前delete的节点的next指向下一个节点的next节点，即next.next。

存在的特殊情况有：

- 该法需判断当前要删除的节点是否有next节点，即要删除的节点是否为最后一个节点，若是，则需要遍历链表，删除倒数第二个节点的next，此时时间复杂度为n
- 链表只有一个节点，即head==tobedelete，删完为空，需要设置head=null



## [面试题21. 调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

示例：

```
输入：nums = [1,2,3,4]
输出：[1,3,2,4] 
注：[3,1,2,4] 也是正确的答案之一。 
```

提示：

    1 <= nums.length <= 50000
    1 <= nums[i] <= 10000

**解答：**

> 双指针法，前后两个指针，start指针指向第一个偶数，last指针指向第一个奇数，交换他们，start向后运动，last向前移动，直到两者相遇

```java
class Solution {
    public int[] exchange(int[] nums) {
        int start = 0;
        int last = nums.length-1;
        while(start<last){
            while(nums[start]%2==1&&start<last) start++;
            while(nums[last]%2==0&&last>start) last--;         
            if(start<last){
                int temp = nums[start];
                nums[start] = nums[last];
                nums[last] = temp;
            }
        }
        return nums;

    }
}
```



## [面试题22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。

示例：

```
给定一个链表: 1->2->3->4->5, 和 k = 2.

返回链表 4->5.
```

**解答：**

双指针法，两个指针相差k，一起向前运动，直到链尾

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        ListNode start = head;
        ListNode last = head;
        int len = 1;
        while(start.next!=null){
            start=start.next;
            if(len<k) len++;
            else last = last.next;
        }
        len++;
        return last;

    }
}
```



## [面试题24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

示例:

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

限制：

`0 <= 节点个数 <= 5000`

**解答：**

双指针：不断向前移动并反转next指针 ⚠️最开始1的next指针要设置为null

![面试题24](/Users/jinzhuoqun/Documents/StudyNotes/力扣刷题记录/resources/面试题24.jpg)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head==null||head.next==null) return head;
        ListNode pre = head.next;
        head.next=null;
        
        while(pre.next!=null){
            ListNode temp = pre.next;
            pre.next = head;;
            head = pre;
            pre = temp;
            
        }
        pre.next = head;

        return pre;
    }
```



## [面试题25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。

示例1：

`输入：1->2->4, 1->3->4`
`输出：1->1->2->3->4->4`

限制：

`0 <= 链表长度 <= 1000`

**解答：**

1.迭代：

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        //if(l1==null) return l2;
        //if(l2==null) return l1;

        ListNode tmp = new ListNode(0);
        ListNode res = tmp;
        //if(l2.val>l1.val) res = l1;
        //else res = l2;

        while(l1!=null && l2!=null){
            if(l2.val>l1.val){
                tmp.next = l1;  
                l1 = l1.next;       
            }
            else{
                tmp.next = l2;
                l2 = l2.next;
                
            }
            tmp = tmp.next;
        }
        if(l1==null) tmp.next = l2;
        if(l2==null) tmp.next = l1;
        return res.next;
    }
}
```

2.递归：

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1==null) return l2;
        if(l2==null) return l1;

        if(l1.val>l2.val){
            l2.next = mergeTwoLists(l1,l2.next);
            return l2;
        }
        else{
            l1.next = mergeTwoLists(l1.next,l2);
            return l1;
        }
    }
}
```



## [面试题26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

例如:
给定的树 A:

```
    3
   / \
  4   5
 / \
1   2
```

给定的树 B：

```
   4 
  /
 1
```


返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。

示例 1：

```
输入：A = [1,2,3], B = [3,1]
输出：false
```

示例 2：

```
输入：A = [3,4,5,1,2], B = [4,1]
输出：true
```

限制：

`0 <= 节点个数 <= 10000`



**解答：**

先序遍历+dfs

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        if(A==null||B==null) return false;
        boolean res,res_left,res_right;
        if(A.val==B.val){
            res_left = true;
            res_right = true;
            if(B.left!=null) res_left = issame(A.left,B.left);
            if(B.right!=null) res_right = issame(A.right,B.right);
            if(res_left&&res_right==true) return true;
        }
                  
        res_left = isSubStructure(A.left,B);
        res_right = isSubStructure(A.right,B); 
        
        return res_left||res_right;

    }
    public boolean issame(TreeNode A, TreeNode B){
        if(A==null||B==null) return false;
        boolean res_left,res_right;
        if(A.val==B.val){
            res_left = true;
            res_right = true;
            if(B.left!=null) res_left = issame(A.left,B.left);
            if(B.right!=null) res_right = issame(A.right,B.right);
            if(res_left&&res_right==true) return true;
        }
        return false;
    }
}
```



简化：

```java
public boolean isSubStructure(TreeNode A, TreeNode B) {
        if(A == null || B == null) return false;
        return dfs(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);
    }
    public boolean dfs(TreeNode A, TreeNode B){
        if(B == null) return true;
        if(A == null) return false;
        return A.val == B.val && dfs(A.left, B.left) && dfs(A.right, B.right);
    }
```



## [面试题27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

例如输入：

```
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```

镜像输出：

```
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

示例 1：

`输入：root = [4,2,7,1,3,6,9]`
`输出：[4,7,2,9,6,3,1]`

限制：

`0 <= 节点个数 <= 1000`

**解答：**

递归：交换左右节点，再针对子节点进行先序遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode mirrorTree(TreeNode root) {
        if(root==null) return null;
        TreeNode tmp = root.left;

        root.left = mirrorTree(root.right);
        root.right = mirrorTree(tmp);

        return root;
    }
}
```

迭代方法：设置一个栈或队列，存储当前需要翻转子节点的节点，最开始只有根节点，根节点转换完左右节点之后出栈，子节点进栈，再翻转栈中节点的子节点…

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null) return null;
        Stack<TreeNode> stack = new Stack();
        stack.push(root);
        while(!stack.empty()){
            TreeNode cre = stack.pop();
            TreeNode tmp = cre.left;
            cre.left = cre.right;
            cre.right = tmp;
            if(cre.left!=null) stack.push(cre.left);
            if(cre.right!=null) stack.push(cre.right);
        }
        return root;
    }
}
```



## [面试题28. 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

```
		1
   / \
  2   2
 / \ / \
3  4 4  3

```

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

```
		1
   / \
  2   2
   \   \
   3    3
```

示例 1：

`输入：root = [1,2,2,3,4,4,3]`
`输出：true`

示例 2：

`输入：root = [1,2,2,null,3,null,3]`
`输出：false`

限制：

0 <= 节点个数 <= 1000

**解答：**

1.递归法，比较 `a.left ？= b.right`  及 `a.right ？= b.left`  

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {

        if(root==null) return true;
        return issame(root.left,root.right);

    }

    public boolean issame(TreeNode a, TreeNode b){
        if(a==null&&b==null) return true;
        if(a==null||b==null) return false;
        if(a.val!=b.val) return false;
        else return issame(a.left,b.right)&&issame(a.right,b.left);
    }
}
```

2.迭代法，利用双头链表，左节点按 right、 left 进队头，右节点按 left、right 进队尾

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {

        if(root==null) return true;
        
        LinkedList<TreeNode> list = new LinkedList<>();
        list.addFirst(root.left);
        list.addLast(root.right);

        while(!list.isEmpty()){
            TreeNode myleft = list.removeFirst();
            TreeNode myright = list.removeLast();
            //该对称节点存在
            if(myleft!=null||myright!=null){ 
                if(myleft==null||myright==null) return false; //该对称节点 有一个为null
                //比较对称节点的值 要保证对称节点不为null   
                if(myleft.val != myright.val) return false;   
                else {
                    list.addFirst(myleft.right);
                    list.addFirst(myleft.left); 
                    list.addLast(myright.left);
                    list.addLast(myright.right);               
                }
            }

        }
        return true;
    }

}
```



## [面试题29. 顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 

示例 1：

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

示例 2：

```
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

限制：

    0 <= matrix.length <= 100
    0 <= matrix[i].length <= 100



**解答：**

顺时针遍历完一圈，再判断，再遍历

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        if(matrix.length==0) return new ArrayList<Integer>();

        List<Integer> res = new ArrayList<Integer>();
        int len = matrix.length * matrix[0].length;
        int tl=0,bl=0;
        int tr = matrix.length-1, br = matrix[0].length-1;
        while(tl<=tr&&bl<=br){
            for(int i = bl;i<=br;i++){
                res.add(matrix[tl][i]);
            }
            tl++;
            if(tl>tr) break;
            for(int i=tl;i<=tr;i++){             
                res.add(matrix[i][br]);
            }
            br--;
            if(br<bl) break;
            for(int i=br;i>=bl;i--){
                res.add(matrix[tr][i]);
                
            }
            tr--;
            if(tr<tl) break;
            for(int i=tr;i>=tl;i--){
                res.add(matrix[i][bl]);
            }
            bl++;
            //if(bl>br) break; //与while条件一致

        }
        return res;
    }
}
```

## [面试题30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

 

示例:

```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.min();   --> 返回 -3.
minStack.pop();
minStack.top();   --> 返回 0.
minStack.min();   --> 返回 -2.
```

提示：

    各函数的调用总次数不超过 20000 次



**解答：**空间换时间，查询min的时间复杂度为1

```java
class MinStack {
    Stack<Integer> A;
    Stack<Integer> B;
    /** initialize your data structure here. */
    public MinStack() {
        A = new Stack<>();
        B = new Stack<>();
    }
    
    public void push(int x) {
        A.push(x);
        if(B.empty()) B.push(x);
        else{
            if(A.peek()<=B.peek()) B.push(x);
        }
    }
    
    public void pop() {  
        // or int a = A.peek(); if(B.peek()==a)?      
        if(B.peek().equals(A.peek())) {
            B.pop();
        }
        A.pop();
    }
    
    public int top() {
        return A.peek();
    }
    
    public int min() {
        return B.peek();

    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.min();
 */
```



## [面试题31. 栈的压入、弹出序列](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。

示例 1：

```
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
```

示例 2：

```
输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。
```

提示：

    0 <= pushed.length == popped.length <= 1000
    0 <= pushed[i], popped[i] < 1000
    pushed 是 popped 的排列。

**解答：**

模拟栈，时间复杂度最多2N=N

```java
class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        if(pushed.length==0||popped.length==0) return true;
        Stack<Integer> stack = new Stack<>();   
        int i=0;
        int j=0;
        while(i<popped.length){
            while(stack.empty()||stack.peek()!=popped[i]){
                if(j>=pushed.length) return false;
                stack.push(pushed[j]);
                j++;
            }
            stack.pop();
            i++;          
        }
        return true;
    }
}
```

or

```java
class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        Stack<Integer> stack = new Stack<>();
        int i = 0;
        for(int num : pushed) {
            stack.push(num); // num 入栈
            while(!stack.isEmpty() && stack.peek() == popped[i]) { // 循环判断与出栈
                stack.pop();
                i++;
            }
        }
        return stack.isEmpty();
    }
}
```



## [面试题32 - I. 从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。

例如:
给定二叉树: [3,9,20,null,null,15,7],

```
		3
   / \
  9  20
    /  \
   15   7
```

返回：

```
[3,9,20,15,7] 
```

提示：

    节点总数 <= 1000

**解答：**

二叉树的广度优先遍历，使用队列：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int[] levelOrder(TreeNode root) {
        if(root==null) return new int[0];
        ArrayList<Integer> ans = new ArrayList<Integer>();//存储结果
        Queue<TreeNode> treelist = new LinkedList<>();//存储当前层级的树节点
        treelist.add(root);
      
				//队列为空时遍历完成
        while(!treelist.isEmpty()){ 
            TreeNode thisnode = treelist.poll(); //节点出队列
            ans.add(thisnode.val);
            if(thisnode.left!=null) treelist.add(thisnode.left); //子节点进队列
            if(thisnode.right!=null) treelist.add(thisnode.right);
        }

        int[] res = ans.stream().mapToInt(Integer::valueOf).toArray(); 
      	//ArrayList转int[]
        return res;

    }
}
```



## [面试题32 - II. 从上到下打印二叉树 II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

例如:
给定二叉树: [3,9,20,null,null,15,7],

```
		3
   / \
  9  20
    /  \
   15   7
```

返回其层次遍历结果：

```
[
  [3],
  [9,20],
  [15,7]
]
```

提示：

    节点总数 <= 1000

**解答：**

二叉树的广度优先遍历，使用队列：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root==null) return new ArrayList<List<Integer>>();;
        List<List<Integer>> res = new ArrayList<List<Integer>>(); //存储结果
        Deque<TreeNode> mytree = new LinkedList<>(); //双端队列用于存储当前层的树节点
        mytree.add(root);

        while(!mytree.isEmpty()){
            List<Integer> mylist = new ArrayList<Integer>();//保存该层级的节点数组
            int len = mytree.size(); //先保存上一级的节点个数 因为在遍历时 该队列还会动态变化
            for(int i=0;i<len;i++){
                TreeNode tmp = mytree.poll();
                mylist.add(tmp.val);
                if(tmp.left!=null) mytree.add(tmp.left); //添加新的子节点进入Deque
                if(tmp.right!=null) mytree.add(tmp.right);
            }
            res.add(mylist);
        }
        return res;



    }
}
```





## [面试题32 - III. 从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。 

例如:
给定二叉树: [3,9,20,null,null,15,7],

```
	  3
   / \
  9  20
    /  \
   15   7
```

返回其层次遍历结果：

```
[
  [3],
  [20,9],
  [15,7]
]
```

提示：

    节点总数 <= 1000

**解答：**

1.双栈法：

奇数次时先进**左**节点，再进**右**节点；偶数次时先进**右**节点再进**左**节点。栈中元素如下：

进栈方向⬅️ 、出栈方向➡️

[3] 

[9,20] 

[7.15]

20出栈的同时，7、15进栈，会扰乱栈顺序，因此使用两个栈来存储节点。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root==null) return new ArrayList<List<Integer>>();
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        Stack<TreeNode> mynode = new Stack<>(); //层次遍历存储节点
        mynode.push(root);
        int count = 1; //判断奇偶
        while(!mynode.isEmpty()){
            List<Integer> list = new ArrayList<Integer>();
            Stack<TreeNode> newnode = new Stack<>(); //存储该层新进入的节点
            int len = mynode.size();
            if(count%2==1){
                for(int i=0;i<len;i++){
                    TreeNode node = mynode.pop();
                    list.add(node.val);
                    if(node.left!=null) newnode.push(node.left);
                    if(node.right!=null) newnode.push(node.right);
                }            
            }
            else{
                 for(int i=0;i<len;i++){
                    TreeNode node = mynode.pop();
                    list.add(node.val);
                    if(node.right!=null) newnode.push(node.right);
                    if(node.left!=null) newnode.push(node.left);
                }                
            }
            count++;
            res.add(list);
            mynode = newnode;
        }

        return res;

    }
}
```

2.双端队列法 LinkedList，只需设置一个队列，保持进出队列方向一致，就不会存在队列顺序混乱的情况

奇数次时 进出队列方向⬆️ removeFirst\addLast 进队列按**先左后右**的顺序

偶数次时 进出队列方向⬇️ removeLast\addFirst 进队列按**先右后左**的顺序

<img src="https://i.loli.net/2020/05/11/UHf7hb2eIVu4jz1.jpg" alt="面试题32 - III" style="zoom: 25%;" />

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root==null) return new ArrayList<List<Integer>>();
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        LinkedList<TreeNode> mynode = new LinkedList<>();
        mynode.add(root);
        boolean count = true;
        while(!mynode.isEmpty()){
            List<Integer> list = new ArrayList<Integer>();
            int len = mynode.size();
            if(count){
                for(int i=0;i<len;i++){
                    TreeNode node = mynode.removeFirst();
                    list.add(node.val);
                    if(node.left!=null) mynode.addLast(node.left);
                    if(node.right!=null) mynode.addLast(node.right);
                }
            }
             else{
                  for(int i=0;i<len;i++){
                     TreeNode node = mynode.removeLast();
                     list.add(node.val);
                     if(node.right!=null) mynode.addFirst(node.right);
                     if(node.left!=null) mynode.addFirst(node.left);
                 }               
             }
            
            //if(!count) Collections.reverse(list);

            res.add(list);
            count = !count;
        }

        return res;

    }
}
```

3.与上一题一致，层序遍历，每层都是从左到右输出，进出队列方向不变，只在最后**reverse**输出的list

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root==null) return new ArrayList<List<Integer>>();
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        LinkedList<TreeNode> mynode = new LinkedList<>();
        mynode.add(root);
        boolean count = true;
        while(!mynode.isEmpty()){
            List<Integer> list = new ArrayList<Integer>();
            int len = mynode.size();
            //if(count){
                for(int i=0;i<len;i++){
                    TreeNode node = mynode.removeFirst();
                    list.add(node.val);
                    if(node.left!=null) mynode.addLast(node.left);
                    if(node.right!=null) mynode.addLast(node.right);
                }
            //}
            // else{
            //      for(int i=0;i<len;i++){
            //         TreeNode node = mynode.removeLast();
            //         list.add(node.val);
            //         if(node.right!=null) mynode.addFirst(node.right);
            //         if(node.left!=null) mynode.addFirst(node.left);
            //     }               
            // }
            
            if(!count) Collections.reverse(list);

            res.add(list);
            count = !count;
        }

        return res;

    }
}
```

## [面试题33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。

参考以下这颗二叉搜索树：

```
     5
    / \
   2   6
  / \
 1   3
```

示例 1：

```
输入: [1,6,3,2,5]
输出: false
```

示例 2：

```
输入: [1,3,2,6,5]
输出: true
```

**解答：**

**后序遍历定义**： [ 左子树 | 右子树 | 根节点 ] ，即遍历顺序为 “左、右、根” 。

**二叉搜索树定义**： 左子树中所有节点的值 <<< 根节点的值；右子树中所有节点的值 >>> 根节点的值；其左、右子树也分别为二叉搜索树。

1.迭代：分析序列，最后一位永远是根节点，从头开始遍历，遇到第一个大于根节点的值时，开始进入右子树，由此可以将一串序列分为左子树序列和右子树序列，再分别迭代

```java
class Solution {
    public boolean verifyPostorder(int[] postorder) {

        return seperateTree(postorder,0,postorder.length-1);
    }

    public boolean seperateTree(int[] postorder,int i,int j){
        if(i>=j) return true;
        int p = i;
        while(postorder[p]<postorder[j]) p++;
        int m = p;
        while(postorder[m]>postorder[j]) m++;
        if(m==j) return seperateTree(postorder,i,p-1)&&seperateTree(postorder,p,j-1);
        else return false;
    }

}

```

2.单调栈：从右向左遍历进栈，一开始都是升序，遇到降序就开始进入左子树（子树的左子树也算），此时开始出栈，大于该值的全部出栈，最后一位出栈的设为p，然后该值进栈，继续遍历，当遇到的值比当前p值大，则顺序错误，返回false。

```java
class Solution {
    public boolean verifyPostorder(int[] postorder) {
        // 单调栈使用，单调递增的单调栈
        Deque<Integer> stack = new LinkedList<>();
        int pervElem = Integer.MAX_VALUE;
        // 逆向遍历，就是翻转的先序遍历
        for (int i = postorder.length - 1;i>=0;i--){
            // 左子树元素必须要小于递增栈被peek访问的元素，否则就不是二叉搜索树
            if (postorder[i] > pervElem){
                return false;
            }
            while (!stack.isEmpty() && postorder[i] < stack.peek()){
                // 数组元素小于单调栈的元素了，表示往左子树走了，记录下上个根节点
                // 找到这个左子树对应的根节点，之前右子树全部弹出，不再记录，因为不可能在往根节点的右子树走了
                pervElem = stack.pop();
            }
            // 这个新元素入栈
            stack.push(postorder[i]);
        }
        return true;
    }
}
```



## [面试题34. 二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。

示例:
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1

返回:

`[`
   `[5,4,11,2],`
   `[5,8,4,5]`
`]`

提示：

节点总数 <= 10000

**解答:**

先序遍历

注意：res.add(list) 这里需要复制list，或者遍历的时候每次向下传递都要复制list。

回溯的时候就是要保证 当前list不变 可以向左向右节点传递。或者存到res里的list不变

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        List<List<Integer>> res = new ArrayList<>();
        res = bianlitree(root,new ArrayList<Integer>(),0,sum,res);
        return res;
    }

    public List<List<Integer>> bianlitree(TreeNode root,List<Integer> list,int mysum,int sum, List<List<Integer>> res){
        if(root==null) return res;

        list.add(root.val);
        mysum = mysum+root.val;
        if(mysum == sum&&root.left==null&&root.right==null){
            res.add(list);
        }
        
        //if(root.left!=null){
            List<Integer> list_1 = new ArrayList(list);///复制list list本质是地址 
            //list_1.addAll(list);
            res = bianlitree(root.left,list_1,mysum,sum,res);
        //}
        
        //if(root.right!=null){
            List<Integer> list_2 = new ArrayList(list);///复制list
            //list_2.addAll(list);
            res = bianlitree(root.right,list_2,mysum,sum,res);
        //} 
        return res;
    }
}
```

官方解答:先序遍历+回溯（无需复制list）

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> list = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        bianlitree(root,sum);
        return res;
    }

    void bianlitree(TreeNode root,int sum){
        if(root==null) return;
        list.add(root.val);
        sum = sum - root.val; //直接从sum中减去
        if(sum==0&&root.left==null&&root.right==null){
            res.add(new ArrayList(list));//复制list list本质是地址 //不复制最终res里是[]
        }
        bianlitree(root.left,sum);
        bianlitree(root.right,sum);
        list.remove(list.size()-1); //回溯 每次调用都会减一 最终返回到根节点时list=[]
    }
}

```



## [面试题35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。

示例 1：

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

示例 2：

```
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
```

示例 3：

```
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
```

示例 4：

```
输入：head = []
输出：[]
```


解释：给定的链表为空（空指针），因此返回 null。

提示：

-10000 <= Node.val <= 10000
Node.random 为空（null）或指向链表中的节点。
节点数目不超过 1000 

**解答：**

本质是做**深拷贝（Deep Copy）** ，链表是存在地址中的，本题的目标是将当前链表复制到新的地址中，并返回新链表的头节点。之所以要分步复制，是因为random节点的复制需要所有节点都已经复制，才能指向新复制的节点。

原链表：7->13->11->10->1->none

复制next节点：7->7->11->11->10->10->1->1->none

复制random节点：7->..

<img src="\resources\面试题35.jpg" alt="面试题35" style="zoom: 25%;" />

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/
class Solution {
    public Node copyRandomList(Node head) {
        if(head==null) return null;

        Node cur = head;
        //复制next节点
        while(cur!=null){
            Node node = cur.next;
            cur.next = new Node(cur.val);
            cur.next.next = node;
            cur = node;
        }

        cur = head;
        //复制random节点
        while(cur!=null){
            Node node_r = cur.random;
            cur.next.random = node_r==null? null:node_r.next;
            cur = cur.next.next;
        }

        cur = head;
        Node res = cur.next;
        //分割节点
        while(cur!=null){
            Node node_n = cur.next;
            cur.next = cur.next.next;
            node_n.next = node_n.next==null? null:node_n.next.next;

            cur = cur.next;
        }

        return res;
    }
}
```



## [面试题36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

 ![1590584472221](\resources\面试题36-1.png)

为了让您更好地理解问题，以下面的二叉搜索树为例：

 

 

我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。

下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。

 ![1590584499930](D:\Study\Notes\力扣刷题记录\resources\面试题36-2)

特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。

**解答：**

二叉搜索树的中序遍历是升序的

```java
//中序遍历
    void dfs(Node cur){
        if(root == null) return;
        dfs(cur.left); //左 
        System.out.println(root.val) //中
        dfs(cur.right);    //右
    }
```

本题指在按照中序遍历的顺序将树结构转化为双向循环链表

<img src="\resources\面试题36-3.jpg" alt="3575dab0c4748696f96031648790325" style="zoom: 25%;" />

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val,Node _left,Node _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
    Node pre, head;
    public Node treeToDoublyList(Node root) {
        if(root==null) return null;
        dfs(root);//中序遍历
        head.left = pre; //连接始末节点
        pre.right = head;

        return head;     
    }
    void dfs(Node cur){
        if(cur==null) return;
        dfs(cur.left);//左子树遍历
        if(pre==null) head=cur;//pre为null 时 是最左叶子节点 暂时没有办法定位左右节点 但该节点是head节点（该树中数最小）
        else{
            cur.left = pre;//当前节点左节点为pre
            pre.right = cur;//pre的右节点为当前节点
        }
        pre = cur;  //pre变为中间节点  
        dfs(cur.right);//右子树遍历
      
    }
}
```



## [面试题37. 序列化二叉树](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)

请实现两个函数，分别用来序列化和反序列化二叉树。

示例: 

你可以将以下二叉树：

```
    1
   / \
  2   3
     / \
    4   5
```

序列化为 "[1,2,3,null,null,4,5]"

**解答:**

题目的目的仅在于将树节点转为字符串序列，再转回来， 无论你使用什么遍历，只要最后能还原回来就行 ，而题中例子的是以层次遍历转化的序列

1.基于层次遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root==null) return "";
        StringBuilder mylist = new StringBuilder();
        Queue<TreeNode> myqueue = new LinkedList<>() {{add(root);}};
        
        while(!myqueue.isEmpty()){

            TreeNode node = myqueue.poll();
            if(node != null) {
               mylist.append(node.val+",");           
               myqueue.add(node.left);
               myqueue.add(node.right); 
            }
            else mylist.append("null,");
        }
 
        return mylist.toString();
        
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if(data.equals("")) return null;
        String[] vals = data.split(",");
        TreeNode root = new TreeNode(Integer.parseInt(vals[0]));
        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};
        int i = 1;
        while(!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if(!vals[i].equals("null")) {
                node.left = new TreeNode(Integer.parseInt(vals[i]));
                queue.add(node.left);
            }
            i++;
            if(!vals[i].equals("null")) {
                node.right = new TreeNode(Integer.parseInt(vals[i]));
                queue.add(node.right);
            }
            i++;
        }
        return root;      
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
```

2.基于先序遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root==null) return "null,";

        String res = root.val+",";
        res += serialize(root.left); //遍历左子树
        res += serialize(root.right); //遍历右子树
        return res;
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        System.out.println(data);
        if(data.equals("null,")) return null;
        String[] vals = data.split(",");//分离string
        Queue<String> queue = new LinkedList<>(); //string数组进栈
        for(int i=0;i<vals.length;i++){
            queue.add(vals[i]);
        }

        return gettree(queue);      
    }
    //输入：[1,2,3,null,null,4,5]
    //序列化结果 ：1,2,null,null,3,4,null,null,5,null,null,

    public TreeNode gettree(Queue<String> queue){
        String str = queue.poll(); //每个node出栈
        if(str.equals("null")) return null; //当前节点左右节点均为 nul l时遍历完成
        TreeNode root = new TreeNode(Integer.valueOf(str));
        root.left = gettree(queue); //左子树遍历
        root.right = gettree(queue); //右子树遍历
        return root;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
```

## [剑指 Offer 38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)

输入一个字符串，打印出该字符串中字符的所有排列。

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。 

**示例:**

```
输入：s = "abc"
输出：["abc","acb","bac","bca","cab","cba"]
```

**限制：**

`1 <= s 的长度 <= 8`

**解答：**回溯法+重复字符删除（即剪枝） $o(N) = N*N-1*N-2*…*2*1$

- 字符串转字符数组，数组长度n

- 固定第一位，x=0，第二位遍历[1,n-1]

- 固定第二位，第三位遍历[2,n-1]

- 固定第x位，第x+1位遍历[x+1,n-1]

- 固定到第n-1位，返回字符串当前序列

- 回溯，退回n-2位，继续遍历n-1位

- 回溯，退回n-3位，继续遍历n-2位

- 回溯至第一位，x=1，继续遍历第二位

- 判断是否是重复元素：建立set，判断set.contains(arr[i])；先对数组进行排序，如果arr[i]==arr[i-1]，为重复元素

  ```java
  class Solution {
      LinkedList<String> res = new LinkedList<>();  //全局变量存储res
      char[] arr;  //全局变量存储数组
  
      public String[] permutation(String s) {
          arr = s.toCharArray(); 
          dfs(0);
          return res.toArray(new String[res.size()]);
  
      }
  
      //深度遍历 x为当前固定的位数
      void dfs(int x){
          //x==arr.length-1 说明递归到最后一位了，则将当前数组转字符串加入res
          if(x==arr.length-1){
              res.add(String.valueOf(arr));
              return;
          }
          HashSet<Character> set = new HashSet<>();
          for(int i=x;i<arr.length;i++){    
              //判断在当前固定的位数上，是否有重复元素
              if(set.contains(arr[i])) continue; 
              set.add(arr[i]);
              
              swap(i,x);//交换 arr[i] 与 arr[x]
              dfs(x+1);
              swap(i,x);//回溯 重置交换
          }
      }
  	//交换数组arr[a] arr[b]
      void swap(int a,int b){
          char temp = arr[a];
          arr[a] = arr[b];
          arr[b] = temp;
      }
  }
  ```

  

## [剑指 Offer 40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)

输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

示例 1：

```
输入：arr = [3,2,1], k = 2
输出：[1,2] 或者 [2,1]
```

示例 2：

```
输入：arr = [0,1,2,1], k = 1
输出：[0]
```

限制：

    0 <= k <= arr.length <= 10000
    0 <= arr[i] <= 10000



**解答：**<u>Top k</u> 问题：快排 / 大根堆（输出前 K 小）

1. 快排：o(n) 每次快排，都是找到该元素i在当前数组中的位置，比它小的在左边，比它大的在右边，如果k<i，继续切分(0,i-1)，如果k<i，切分(i+1,len)

   ```java
   class Solution {
       public int[] getLeastNumbers(int[] arr, int k) {
           if (k == 0 || arr.length == 0) {
               return new int[0];
           }
           // 最后一个参数表示我们要找的是下标为k-1的数
           return quickSearch(arr, 0, arr.length - 1, k - 1);
       }
   
       private int[] quickSearch(int[] nums, int lo, int hi, int k) {
           // 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；
           int j = partition(nums, lo, hi);
           if (j == k) {
               return Arrays.copyOf(nums, j + 1);
           }
           // 否则根据下标j与k的大小关系来决定继续切分左段还是右段。
           return j > k? quickSearch(nums, lo, j - 1, k): quickSearch(nums, j + 1, hi, k);
       }
   
       // 快排切分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。
       private int partition(int[] nums, int lo, int hi) {
           int v = nums[lo];
           int i = lo, j = hi + 1;
           while (true) {
               while (++i <= hi && nums[i] < v);
               while (--j >= lo && nums[j] > v);
               if (i >= j) {
                   break;
               }
               int t = nums[j];
               nums[j] = nums[i];
               nums[i] = t;
           }
           nums[lo] = nums[j];
           nums[j] = v;
           return j;
       }
   }
   ```

2. 大根堆(前 K 小) / 小根堆（前 K 大),Java中有现成的 PriorityQueue，实现起来最简单：O(NlogK)O(NlogK)O(NlogK)

   ```java
   // 保持堆的大小为K，然后遍历数组中的数字，遍历的时候做如下判断：
   // 1. 若目前堆的大小小于K，将当前数字放入堆中。
   // 2. 否则判断当前数字与大根堆堆顶元素的大小关系，如果当前数字比大根堆堆顶还大，这个数就直接跳过；
   //    反之如果当前数字比大根堆堆顶小，先poll掉堆顶，再将该数字放入堆中。
   class Solution {
       public int[] getLeastNumbers(int[] arr, int k) {
           if (k == 0 || arr.length == 0) {
               return new int[0];
           }
           // 默认是小根堆，实现大根堆需要重写一下比较器。
           Queue<Integer> pq = new PriorityQueue<>((v1, v2) -> v2 - v1);
           for (int num: arr) {
               if (pq.size() < k) {
                   pq.offer(num);
               } else if (num < pq.peek()) {
                   pq.poll();
                   pq.offer(num);
               }
           }
           
           // 返回堆中的元素
           int[] res = new int[pq.size()];
           int idx = 0;
           for(int num: pq) {
               res[idx++] = num;
           }
           return res;
       }
   }
   ```




## [剑指 Offer 41. 数据流中的中位数](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)

#### 

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。

例如，

[2,3,4] 的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

设计一个支持以下两种操作的数据结构：

- void addNum(int num) - 从数据流中添加一个整数到数据结构中。
- double findMedian() - 返回目前所有元素的中位数。

**示例 1：**

```
输入：
["MedianFinder","addNum","addNum","findMedian","addNum","findMedian"]
[[],[1],[2],[],[3],[]]
输出：[null,null,null,1.50000,null,2.00000]
```

**示例 2：**

```
输入：
["MedianFinder","addNum","findMedian","addNum","findMedian"]
[[],[2],[],[3],[]]
输出：[null,null,2.00000,null,2.50000]
```

**解答：**<u>大顶堆+小顶堆</u>

Java PriorityQueue <u>优先队列</u> 队顶始终是当前队列的最小值

小顶堆 ：`Queue<Integer> A = new PriorityQueue<Integer>();` 出队时poll的是最小值

大顶堆 ：`Queue<Integer> B = new PriorityQueue<>((x, y) -> (y - x));` 出队时poll的是最大值

方法：

入队：`A.offer(xxx)`

出队：`A.poll()` 

取队顶：`A.peek()`

PriorityQueue并不是线程安全队列，因为offer/poll都没有对队列进行锁定，每次仅会找出最小的元素将其排在第一位，而不会排序

- 分为大顶堆A 和 小顶堆B，大顶堆A存[5 4 3 2 1]，小顶堆B存[6,7,8,9]
- A.len 与 B.len 相等时，将B及add(num)中最小的值给A，A.len++
- A.len > B.len 时，将A及add(num)中最小的值给B，B.len++
- 相等为偶数，返回两个队顶的均值；不相等为奇数，由于A.len>=B.len，奇数时中位数总在A的队顶

```java
class MedianFinder {

    /** initialize your data structure here. */
    Queue<Integer> A = new PriorityQueue<>((x,y)->(y-x));  //大顶堆 保存 54321 出队返回最大值
    Queue<Integer> B = new PriorityQueue<>();  //小顶堆 保存 6789 出队返回最小值

    public MedianFinder() {

    }
    
    public void addNum(int num) {
        //始终保持A.len>=B.len 并且 A存较小的数 B存较大的数
        if(A.size()==B.size()){
            //AB长度相等时
            //将B及num中最小的值给A  A.len++
            B.offer(num);
            A.offer(B.poll());  
        }else{
            //(A.len-B.len)==1时
            //将A及num中最大的值给B
            A.offer(num);
            B.offer(A.poll());
        }
    }
    
    public double findMedian() {
        //相等为偶数 返回两个队顶的均值 不相等为奇数 由于A.len>=B.len 奇数时中位数总在A的队顶
        return A.size()==B.size()? (A.peek()+B.peek())/2.0:A.peek();   
    }
}

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder obj = new MedianFinder();
 * obj.addNum(num);
 * double param_2 = obj.findMedian();
 */
```

注意 返回类型为double，除以2时要除2.0



## [剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

示例1:

```
输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

提示：

`1 <= arr.length <= 10^5`
`-100 <= arr[i] <= 100`

**解答：**<u>动态规划</u> 

dp[i-1]<0 dp[i]=nums[i]; dp[i-1]>=0 dp[i]=nums[i]+dp[i+1]

nums = [-2,1,-3,4,-1,2,1,-5,4]

dp = [-2,1,-2,4,3,5,6,1,5]  

dp[i]表示以nums[i]为结尾的子数组的最大和 

初始化 dp[0] = nums[0]

```java
class Solution {
    public int maxSubArray(int[] nums) {
        //动态规划 dp[i-1]<0 dp[i]=nums[i]; dp[i-1]>=0 dp[i]=nums[i]+dp[i+1]
        if(nums.length==0) return 0;
        int[] dp = new int[nums.length];
        int res = nums[0];
        dp[0] = nums[0];
        for(int i=1;i<nums.length;i++){
            dp[i] = dp[i-1] < 0 ? nums[i] : nums[i] + dp[i-1];
            res = res > dp[i] ? res:dp[i];
        }
        return res;
    }
}
```

## [剑指 Offer 43. 1～n整数中1出现的次数](https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/)

输入一个整数 `n` ，求1～n这n个整数的十进制表示中1出现的次数。

例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。【11算两次】

**示例 1：**

```
输入：n = 12
输出：5
```

**示例 2：**

```
输入：n = 13
输出：6
```

 **解答：**递归，遍历n中的每个位，1出现的次数-就是每一位上1出现的次数之和， 【如 13】

- cur > 1 时：次数 = $(high+1)* 10^{i-1} $  【1 : cur=3,high=1,low=0,i=1,res+=(1+1)*1=2】
- cur = 1 时：次数 = $ high * 10^{i-1} + low + 1$  【2：cur=2,high=0,low=3,i=2,res+=0+3+1=4】

- cur = 0 时：次数 = $(high-1+1)*10^{i-1}$

cur : 当前位数值

high : 高位部分数值

low : 低位部分数值

i : 当前cur所在的位次

```java
class Solution {
    public int countDigitOne(int n) {
        int res = 0;
        int cur = n%10, low = 0, high = n/10;
        int count = 1;//记录cur现在是第几位 个位/十位…
        int num = 1;//记录cur现在是第几位 1/2… 
        //1出现的次数 就是每一位上1出现的次数之和
        while(low!=n){
            if(cur>1) res = res + (high+1)*(int)Math.pow(10,num-1); //Math.pow(10,num-1) = count
            else if(cur==1) res = res + high*(int)Math.pow(10,num-1)+low+1;
            else res = res + high*(int)Math.pow(10,num-1);
            //cur向前移动
            low = low + cur*count;
            cur = high%10;
            high = high/10;
            count = count*10;
            num++;
        }

        return res;
    }
}
```

## [剑指 Offer 44. 数字序列中某一位的数字](https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/)

数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。

请写一个函数，求任意第n位对应的数字。

示例 1：

```
输入：n = 3
输出：3
```

示例 2：

```
输入：n = 11
输出：0
```

限制：

`0 <= n < 2^31`

**解答：** 找规律

| 数字区间               | 0    | 1-9  | 10-99 | 100-999 | $10^{i-1}-9*10^{i-1}$ |
| ---------------------- | ---- | ---- | ----- | ------- | --------------------- |
| 该区间数字的位数 i     | 1    | 1    | 2     | 3       | $i$                   |
| 整个区见所占位数 count | 1i   | 9*1  | 90*2  | 900*3   | $9*10^{i-1}*i$        |

- n=n-1 //删去0这个数字
- 初始化 i = 1，count = $9*10^{i-1}*i$ = 9
- if(n>count) //n所在的num在当前count区见之后 则 $n = n- 9*10^{i-1}*i$ ；i++；count更新
- 当 n<=count 时，即找到n所在的区间，并且n/i=num是当前区间的第几个数，n%i代表该数的第几位

```java
class Solution {
    public int findNthDigit(int n) {
        if(n==0) return 0;
        n = n - 1; 
        int i = 1;
        //一位数字 1-9 共9位;
        //两位数字 10-99 共90*2位;
        //三位数字 100-999 共900*3位;
        // …… i位数字 共9*10^(i-1)*i位
        long count = 9*(long)Math.pow(10,i-1)*i;
        while(n>count){
            n-=count;
            i++;
            count = 9 * (long)Math.pow(10,i-1)*i;
            
        }
        //n=n-1;
        long num = n/i + (long)Math.pow(10,i-1); //第几位+该区间start的数 1/10/100…
        //System.out.println(num);
        //char res = String.valueOf(num).charAt(n%(int)i);//该数的第几位

        return (int)String.valueOf(num).charAt(n%(int)i)-(int)('0'); //char转int

    }
}
```



## 57.和为s的两个数字

输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。

示例 1：

```
输入：nums = [2,7,11,15], target = 9

输出：[2,7] 或者 [7,2]
```

示例 2：

```
输入：nums = [10,26,30,31,47,60], target = 40

输出：[10,30] 或者 [30,10]
```

限制：

  `1 <= nums.length <= 10^5`

  `1 <= nums[i] <= 10^6`

限制时间复杂度小于n方

**解答：**

1. 双指针：

   ```java
   int i=0,j=max-1;
   while((nums[i]+nums[j])!=target){
       if(nums[i]+nums[j]>target) j--;
       else i++;
   }
   ```

   

2. .二分查找

   ```java
   public int findNum(int[] nums,int l,int r,int res){
       if(l<=r){
           int start = nums[(l+r)/2];
           if(start==res){
               System.out.println(start);
               return start;
           }
           else if(start>res) return findNum(nums,l,(l+r)/2-1,res);
           else return findNum(nums,(l+r)/2+1,r,res);
       }
       return 0;
   }
   ```




## 57-2.和为s的连续正数序列

输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。

序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

示例 1：

```
输入：target = 9
输出：[[2,3,4],[4,5]]
```

示例 2：

```
输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]
```



**解法**：

设置两个指针 初始化1、2

滑动窗口 min<max<tar

窗口内和>tar  min++

窗口内和<tar max++

相等的时候存一下 min max 的值（可以用map）

也可以直接循环存储数组

 

由于二维数组的行数在数组定义的时候必须指明，最后可以截取数组

```java
int lastresult[][] = new int[num][];
        System.arraycopy(result,0,lastresult,0,num);//调用copy方法
```



## [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

示例:

给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

```
      0
     / \
   -3   9
   /   /
 -10  5
```

**解答:**

1. 中序遍历，总选择序列中间的数作为下一个节点，如[-10,-3,0,5,9]
2. 将0作为根节点，递归序列nums[0:1]，nums[3:4]分别作为根节点的左右节点
3. 返回 left = nums[(0+1)/2] = nums[0] = -10，left 作为根节点，再递归序列：nums[0:-1]，nums[1:1]
4. 返回 right = nums[(3+4)/2] = nums[3] = 5，right 作为根节点，再递归序列：nums[3:2]，nums[4:4]
5. 当i>j时,返回null

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        TreeNode res = gettree(nums,0,nums.length-1); //递归
        return res;

    }

    TreeNode gettree(int[] nums,int i, int j){
        if(i>j) return null;
        else {
            TreeNode node = new TreeNode(nums[(i+j)/2]);//根节点
            node.left = gettree(nums,i,(i+j)/2-1); //左节点
            node.right = gettree(nums,(i+j)/2+1,j); //右节点
            return node;
        }
    }

}
```



## [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明: 叶子节点是指没有子节点的节点。

示例: 
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1

返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。

**解答：**

1. DFS递归：o(N)，深度优先遍历

   - 当左右子节点都为null（叶节点）且count==sum，返回true
   - 空节点时返回false，说明上一个节点（可能是叶节点也可以是中间节点）的count!=sum
   - 当有一条路径为true时，返回true

   ```java
   /**
    * Definition for a binary tree node.
    * public class TreeNode {
    *     int val;
    *     TreeNode left;
    *     TreeNode right;
    *     TreeNode(int x) { val = x; }
    * }
    */
   class Solution {
       public boolean hasPathSum(TreeNode root, int sum) {
          // if(root==null) return false;
           return findroad(root,0,sum);
       }
   
       boolean findroad(TreeNode root,int count,int sum){
           if(root==null) return false;
           
           count+=root.val;     
           if(root.left==null&&root.right==null&&count==sum) return true; 
           
           return findroad(root.left,count,sum)||findroad(root.right,count,sum);      
       }
   }
   ```

2. BFS+队列，o(n)，广度优先+用两个队列分别存储当前层的树节点和每个节点所在路径的count

   - 当前节点进队列1，计算count进队列2
   - 节点出队列1，count出队列2，左右节点进队列1，加上左右节点的值再进队列2
   - 如果出队列的节点是叶子节点，且对应count!=sum，则countinut，下一个节点继续出队列
   - 如果出队列的节点是叶子节点，且对应count==sum，则返回true
   - 如果队列空了，返回false

   ```java
   class Solution {
       public boolean hasPathSum(TreeNode root, int sum) {
           if (root == null) {
               return false;
           }
           Queue<TreeNode> queNode = new LinkedList<TreeNode>();  //队列1
           Queue<Integer> queVal = new LinkedList<Integer>();  //队列2
           queNode.offer(root); //根节点进队列1
           queVal.offer(root.val); //根节点的值进队列2
           while (!queNode.isEmpty()) {  //判断队列是否为空
               TreeNode now = queNode.poll(); //出队列1
               int temp = queVal.poll();  //出队列2
               if (now.left == null && now.right == null) { //判断是否为叶节点
                   if (temp == sum) {  //判断该路径count==sum?true:continue;
                       return true;
                   }
                   continue;
               }
               if (now.left != null) {  //左节点不为空 左节点进队列
                   queNode.offer(now.left);
                   queVal.offer(now.left.val + temp);
               }
               if (now.right != null) {  //右节点不为空 右节点进队列
                   queNode.offer(now.right);
                   queVal.offer(now.right.val + temp);
               }
           }
           return false;
       }
   }
   ```

   

## 136.只出现一次的数字

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

```
输入: [2,2,1]

输出: 1
```

示例 2:

```
输入: [4,1,2,1,2]

输出: 4
```

**解法：**

【解法一】：暴力查找

两次循环，代码略

【解法二】：排序

使用快排，复杂度 O(nlogn)O(nlogn)O(nlogn)

```java
public int singleNumber(int[] nums) {
        kuaipai(nums,0,nums.length-1);
        for(int i=0;i<nums.length;i++){
            if(i==nums.length-1) return nums[nums.length-1];
            else if(nums[i]!=nums[++i]) return nums[i-1];
        }
        return 0;
    }

//快排
public void kuaipai(int[] nums,int l,int r){
    if (l < r){
        int i =l;
        int j =r;
        int X = nums[l];
        while(l<r){
            while(l<r&&X<=nums[r]) r--;
            if(l<r) nums[l++]=nums[r];

            while(l<r&&nums[l]<X) l++;
            if(l<r) nums[r--] = nums[l];
        }
        nums[l] = X;
        System.out.println(Arrays.toString(nums));
        kuaipai(nums,i,l-1);
        kuaipai(nums,l+1,j);
    }
}
```

【解法三】：

利用 Hash 表，Time: O(n)O(n)O(n) Space: O(n)O(n)O(n)



【方法 1】：列表操作

```java
class Solution {
  public int singleNumber(int[] nums) {
     List list = new LinkedList<>();
    for (int num : nums) {
      if (!list.contains(num)) {
        list.add(num);
      } else {
        list.remove((Object)num);
      }
    }
    return list.get(0);
//list是线性存储
  }
}
 
```

【方法 2】：哈希表

```java
class Solution {
    public int singleNumber(int[] nums) {
        Map<Integer, Object> map = new HashMap<>();
        for (int num : nums) {
            if (!map.containsKey(num)) {
                map.put(num, null);
            } else {
                map.remove(num);
            }
        }
        return map.keySet().iterator().next();
// keySet() : 获取Map集合中所有的键，存储到Set集合中
// iterator 迭代器
    }  
}

```

【方法 3】：数学

```java
class Solution {
    public int singleNumber(int[] nums) {
        Integer[] numArray = Arrays.stream(nums).boxed().toArray(Integer[]::new);
        int sum = 0;
        for (int i = 0; i < numArray.length; i++) {
            sum += numArray[i];
        }
        Set<Integer> set = new HashSet<>(Arrays.asList(numArray));
        int setSum = set.stream().mapToInt(Integer::intValue).sum();
        return 2 * setSum - sum;
    }
}

```

【方法 4】：位操作

```java
class Solution {
    public int singleNumber(int[] nums) {
        int result = nums[0];
        for(int i=1;i<nums.length;i++){
            result = result ^ nums[i];
        }
        return result;
    }
}
```



## 178.分数排名

编写一个 SQL 查询来实现分数排名。如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。

```
+----+-------+
| Id | Score |
+----+-------+
| 1  | 3.50  |
| 2  | 3.65  |
| 3  | 4.00  |
| 4  | 3.85  |
| 5  | 4.00  |
| 6  | 3.65  |
+----+-------+
```

例如，根据上述给定的 Scores 表，你的查询应该返回（按分数从高到低排列）：

```
+-------+------+
| Score | Rank |
+-------+------+
| 4.00  | 1    |
| 4.00  | 1    |
| 3.85  | 2    |
| 3.65  | 3    |
| 3.65  | 3    |
| 3.50  | 4    |
+-------+------+
```



**解答：**

![](F:\FightingJZQ\力扣刷题记录\resources\178_pic_1.png)

```sql
select Score,(select count(distinct Score) from Scores where Score >= s.score) as Rank from Scores s order by Score desc
```

or

```sql
select a.score,(select count(distinct b.score) from Scores b where b.score>=a.score)as Rank from Scores a order by a.score desc
```

```sql
order by xxx asc/desc 按升序降序排列
count(distinct xxx) 计算非重复(distinct)结果的数目
```



## 260.只出现一次的数字 III

给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。

**示例 :**

```
输入: [1,2,1,3,2,5]
输出: [3,5]
```

**注意**：

结果输出的顺序并不重要，对于上面的例子， [5, 3] 也是正确答案。

你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？



**解答：**

1. 与运算 & ： 1&1 = 1 其余均为0
2. 或运算 | ： 1|1 =1 ，1|0 =1 ，0|0 =0
3. 非运算 ~ ：相当于补码 0变1,1变0
4. 异或运算^: 两数相同时为0，1^1=0 , 0^0=0 , 1^0=1

**反码 等于补码取反加一**   即 -x = ~x + 1

**x与反码做与运算(&)** ：仅保留最右端的1 

即 x&(-x) = x&(~x+1)



`nums = [1,2,1,3,2,5]`

对数组nums做 异或^ 运算：所有偶数个字符抵消

只剩 `bit = 3^5=(011)^(101) = 110 =6`

 

 现在的目标是将bit中的3或5分离，而bit中的1一定来自3 或者 5

`diff = bit&(-bit) = (110)&(001+1)= (110)&(010)=(010) = 2` 

能够 仅保留bit最右端的1，该1一定来自3 或者 5

再次遍历 nums，`(num&diff)==0` 时，可以筛出所有第二位为0的数字（必是奇数）

将这些筛出的 num 做异或运算，筛掉所有重复数字，仅剩 `5 =101`

再将5与bit做异或，`5 ^ bit = 3` 解答完成

```java
public int[] singleNumber(int[] nums) {
    int bit = 0;
    for(int num:nums){
        bit = bit^num;
    }
    int diff = bit&(-bit);

    int x=0;
    for(int num:nums){
           
        if((diff&num)==0){
            x = x^num; 
            System.out.println(num);
        } 
    }
    return new int[]{x,bit^x};
}
```



## [718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

示例：

```
输入：
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出：3
解释：
长度最长的公共子数组是 [3, 2, 1] 。
```

提示：

`1 <= len(A), len(B) <= 1000`
`0 <= A[i], B[i] < 100`

**解答：**

1.暴力法：

- 对于每个A中的元素a，遍历B看是否有元素b和它相同
- **a**与b相同则比较a++与b++的元素，len++，如果a++ b++也相同则继续向后比较，直到遇到不相同的元素的时候，res = len>res?len:res，下一次遍历比较**a**与b++
- a与b不同，比较a与b++
- 两个for循环+一个while

2.动态规划dp：

- A[a]与B[b]如果相同，则以ab结尾的公共子串的长度，是以A[a-1]B[b-1]结尾的公共子串的长度+1，如果A[a-1]不等于B[b-1]，则ab结尾的公共子串的长度为1，记录最长的公共子串长度

- 令dp[i+1] [j+1]表示以A[i]与B[j]结尾的公共子串的长度，则dp[i+1] [j+1] = dp[i] [j]+1，dp大小为[m+1] [n+1],第一行第一列均为0，遍历时从11开始

- A[i]B[j]不等的话 dp[i+1] [j+1] = 0

  ```java
  //伪代码：
  m = A.length
  n = B.length
  dp = int[m+1][n+1]
  for(int i=0;i<m;i++){
  	for(int j=0;j<n;j++){
  		if(A[i]==B[j]){
  			dp[i+1][j+1] = dp[i][j]+1;
  			res = dp[i+1][j+1]>res? dp[i+1][j+1]:res;
  		}
  		else dp[i+1][j+1]=0;	
  	}
  }
  return res;
  ```

<img src="/718-2.png" alt="718-2" style="zoom:75%;" />

3.滑动窗口：

![718](\resources\718.gif)

```java
class Solution {
    public int findLength(int[] A, int[] B) {
        int n = A.length, m = B.length;
        int ret = 0;
        for (int i = 0; i < n; i++) {
            int len = Math.min(m, n - i);
            int maxlen = maxLength(A, B, i, 0, len);
            ret = Math.max(ret, maxlen);
        }
        for (int i = 0; i < m; i++) {
            int len = Math.min(n, m - i);
            int maxlen = maxLength(A, B, 0, i, len);
            ret = Math.max(ret, maxlen);
        }
        return ret;
    }

    public int maxLength(int[] A, int[] B, int addA, int addB, int len) {
        int ret = 0, k = 0;
        for (int i = 0; i < len; i++) {
            if (A[addA + i] == B[addB + i]) {
                k++;
            } else {
                k = 0;
            }
            ret = Math.max(ret, k);
        }
        return ret;
    }
}
```

## [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

示例:

```
输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

**解答：**<u>动态规划</u>

设置二维数组 dp [prices.length] [3]

dp [i] [0]  // 不持股不卖出

dp [i] [1]  // 持股

dp [i] [2]  // 当天卖出

| 股价                      | 1    | 2               | 3               | 0             | 2             |
| ------------------------- | ---- | --------------- | --------------- | ------------- | ------------- |
| dp [i] [0]   不持股不卖出 | 0    | 0               | max(0,1)=1      | max(1,2)=2    | max(2,-1) = 2 |
| dp [0] [1]  持股          | -1   | max(-2,-1) = -1 | max(-3,-1) = -1 | max(1,-1) = 1 | max(0,1) = 1  |
| dp [0] [2]  当天卖出      | 0    | 1               | 2               | -1            | 3             |

return  max( dp [4] [0] , dp [4] [2] )

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length==0) return 0;
        int[][] dp = new int[prices.length][3];
        dp[0][0] = 0; //不持股不卖出
        dp[0][1] = -prices[0];  //持股
        dp[0][2] = 0; //当天卖出

        for(int i=1;i<prices.length;i++){
            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][2]);  //max(前一天不持股/前一天卖出,今天是冷冻期)
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);  //max(前一天已持有/今天买入=昨天dp0-今天股价)
            dp[i][2] = dp[i-1][1] + prices[i]; //当天卖出
        }

        return Math.max(dp[prices.length-1][0],dp[prices.length-1][2]);

    }
}
```



## 908.最小差值 I

给定一个整数数组 `A`，对于每个整数 `A[i]`，我们可以选择任意 `x` 满足 `-K <= x <= K`，并将 `x` 加到 `A[i]` 中。

在此过程之后，我们得到一些数组 `B`。

返回 `B` 的最大值和 `B` 的最小值之间可能存在的最小差值。

示例 1：

```
输入：A = [1], K = 0
输出：0
解释：B = [1]
```

示例 2：

```
输入：A = [0,10], K = 2
输出：6
解释：B = [2,8]
```

示例 3：

```
输入：A = [1,3,6], K = 3
输出：0
解释：B = [3,3,3] 或 B = [4,4,4]
```



**解答：**

先排序，算差值

当 差值res>2*K，最小差值就是 [max(A)-K]-[min(A)+K]=res-2*K

当 差值res<=2*K，最小差值就是 0，A中所有数均能通过加减到一个数。

```java
class Solution {
    public int smallestRangeI(int[] A, int K) {
        Arrays.sort(A);
        
        int res = A[A.length-1] - A[0];
        if(res>2*K) return res-2*K;
        else return 0;

        //循环判断法
        //int min = A[0]+K;
        //int max = A[A.length-1]-K;
        //for(int i=1;i<A.length;i++){
            //if(A[i]<min) A[i] = min; 
        //}
        //if(max<min) max = min;
        //return max-min;  
    }
}
```



## 1122. 数组的相对排序

给你两个数组，arr1 和 arr2，

- arr2 中的元素各不相同
- arr2 中的每个元素都出现在 arr1 中

对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。



 示例：

```
输入：
arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]

输出：
[2,2,2,1,4,3,3,9,6,7,19]
```

提示：

```
  arr1.length, arr2.length <= 1000
  0 <= arr1[i], arr2[i] <= 1000
  arr2 中的元素 arr2[i] 各不相同
  arr2 中的每个元素 arr2[i] 都出现在 arr1 中
```



**解答：**

```java
HashMap<Integer, Integer> map = new HashMap<>();
```

将arr1中数据存成map<值，出现次数>

将map按arr2的排列存成数组，并remove该键值

将剩下的键值按升序输出

（键值范围是0~1000，可以直接循环1000次判断是否存在该键值并依次输出到数组）